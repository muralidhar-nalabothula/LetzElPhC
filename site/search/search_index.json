{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>     Logo designed by Henry Fried   </p>"},{"location":"#welcome-to-letzelphc-documentation","title":"Welcome to LetzElPhC Documentation","text":"<p>This is the official documentation for the LetzElPhC project. Here you will find installation instructions, usage examples.</p>"},{"location":"#about-the-code","title":"About the Code","text":"<p>LetzElPhC is a C code designed to compute electron-phonon coupling matrix elements from the outputs of standard Density Functional Theory (DFT) and Density Functional Perturbation Theory (DFPT) calculations. Currently, it only supports Quantum Espresso, with plans for Abinit. The main objective is to facilitate electron-phonon calculations within Yambo (version 5.2+). The code is released under the MIT license and hosted on GitHub: link.</p>"},{"location":"#main-features","title":"Main Features","text":"<ul> <li>Utilizes full crystal symmetries, ensuring compatibility with Yambo code</li> <li>Multiple levels of parallelization (OpenMP, plane-wave, k-point, q-point)</li> <li>Fully parallel I/O via NetCDF-4/HDF5</li> <li>Highly portable across CPU architectures and OS</li> </ul>"},{"location":"installing/","title":"Installing the Code","text":""},{"location":"installing/#mandatory-requirements","title":"Mandatory Requirements","text":"<ul> <li>GNU Make</li> <li>C99 compiler with complex number support (GCC, Clang, ICC, AMD C-Compiler, MinGW, PGI, Arm C compilers)</li> <li>MPI implementation (Open-MPI, MPICH, Intel MPI, Microsoft MPI)</li> <li>FFTW-3 or Intel MKL</li> <li>HDF5 and NETCDF-4 libraries with Parallel IO support</li> <li>BLAS library (OpenBLAS, BLIS, Intel-MKL, Atlas)</li> </ul>"},{"location":"installing/#installation-process","title":"Installation Process","text":"<p>LetzElPhC uses a standard Make build system. Sample make files are in the <code>sample_config</code> directory.  </p> <ol> <li>Copy a sample to the <code>src</code> directory and rename it <code>make.inc</code>.  </li> <li>Edit <code>make.inc</code> according to your requirements.  </li> <li>In <code>src/</code> execute:</li> </ol> <pre><code>$ make\n$ make -j n   # where n is the number of processes\n</code></pre> <p>Upon success, the <code>lelphc</code> executable will be in the <code>src/</code> directory.</p>"},{"location":"installing/#key-variables-in-makeinc","title":"Key Variables in <code>make.inc</code>","text":"<pre><code>CC        := mpicc          # MPI C compiler\nCFLAGS    := -O3            # Optimization\nLD_FLAGS  :=                # Additional linker flags\n\n# Optional OpenMP support\n# OPENMP_FLAGS := -DELPH_OMP_PARALLEL_BUILD\n# CFLAGS      += -fopenmp   # or -qopenmp for Intel\n# LD_FLAGS    += -fopenmp   # or -qopenmp for Intel\n\n# FFTW3\nFFTW_INC  := -I/opt/homebrew/include\nFFTW3_LIB := -L/opt/homebrew/lib -lfftw3_threads -lfftw3f -lfftw3f_omp -lfftw3_omp -lfftw3\n\n# BLAS\nBLAS_LIB  := -L/opt/homebrew/opt/openblas/lib -lopenblas\n\n# NetCDF\nNETCDF_INC := -I/Users/murali/softwares/core/include\nNETCDF_LIB := -L/Users/murali/softwares/core/lib -lnetcdf\n\n# HDF5\nHDF5_LIB := -L/opt/homebrew/lib -lhdf5\n\n# Extra include dirs / libs\nINC_DIRS := \nLIBS     := \n</code></pre> <p>Notes: Add <code>-DCOMPILE_ELPH_DOUBLE</code> to <code>CFLAGS</code> for double precision. Use <code>-DELPH_OMP_PARALLEL_BUILD</code> and enable OpenMP flags for parallel builds.</p>"},{"location":"running/","title":"Running the Code","text":""},{"location":"running/#step-0-running-dft-and-dfpt","title":"Step 0: Running DFT and DFPT","text":"<p>Before using LetzElPhC, ensure you have:</p> <ul> <li>Kohn-Sham wavefunctions from an SCF calculation</li> <li>Phonon eigenvectors and perturbed potentials from DFPT</li> </ul>"},{"location":"running/#steps-with-quantum-espresso","title":"Steps with Quantum Espresso","text":"<ol> <li>Run SCF calculation.  </li> <li>Run DFPT calculation using <code>ph.x</code> to obtain dynamical matrices and potential changes.  </li> <li>Run NSCF calculation on a uniform k-point grid.  </li> </ol> <p>Note: The q-grid must be commensurate with the k-grid. Use <code>dvscf</code> flag to save changes in potentials.  </p>"},{"location":"running/#prepare-save-folder","title":"Prepare SAVE folder","text":"<pre><code>$ p2y\n$ yambo\n</code></pre> <p>This generates the SAVE folder needed by LetzElPhC.</p>"},{"location":"running/#step-1-preprocessor","title":"Step 1: Preprocessor","text":"<p>Create the <code>ph_save</code> folder:</p> <pre><code>$ cd /path/to/phonon_calc_dir\n$ lelphc -pp --code=qe -F PH.X_input_file\n</code></pre> <p>Optional environment variables:</p> <pre><code>$ export ELPH_PH_SAVE_DIR=ph_save_name_you_want\n# Use symlinks instead of copying files\n$ export ELPH_COPY_CMD=\"ln -sr\"\n</code></pre>"},{"location":"running/#final-step-perform-elph-calculation","title":"Final Step: Perform ELPH Calculation","text":"<p>Run the calculation in any folder with the LetzElPhC input file:</p> <pre><code>$ mpirun -n 4 lelphc -F LetzElPhC_input_file\n</code></pre>"},{"location":"running/#example-input-variables","title":"Example input variables:","text":"<pre><code>nkpool      = 1   # k point parallelization\nnqpool      = 1   # q point parallelization\nstart_bnd   = 1   # starting band\nend_bnd     = 40  # last band\nsave_dir    = SAVE\nph_save_dir = ph_save\nkernel      = dfpt\nconvention  = standard\n</code></pre>"},{"location":"running/#el-ph-calculation-for-yambo-via-letzelphc-using-yambopy","title":"El-ph Calculation for Yambo via LetzElPhC using Yambopy","text":"<p>This section shows how Yambopy can be used to run LetzElPhC and generate NetCDF databases for Yambo.</p>"},{"location":"running/#requirements","title":"Requirements","text":"<ul> <li>LetzElPhC installed</li> <li>Yambopy installed</li> <li><code>pw.x</code>, <code>ph.x</code>, <code>p2y</code>, <code>yambo</code> available</li> </ul>"},{"location":"running/#scf-calculation","title":"SCF Calculation","text":"<p>Run a standard SCF calculation with symmorphic symmetries:</p> <pre><code>force_symmorphic = .true.  # in system card\n</code></pre>"},{"location":"running/#nscf-calculation","title":"NSCF Calculation","text":"<p>Copy the SCF <code>save</code> directory and run NSCF for desired empty states.</p>"},{"location":"running/#dvscf-calculation","title":"DVSCF Calculation","text":"<pre><code>prefix_dvscf\n&amp;inputph\n  tr2_ph = 1.0d-14,\n  verbosity = 'high',\n  prefix = 'prefix',\n  fildvscf = 'prefix-dvscf',\n  electron_phonon = 'dvscf',\n  fildyn = 'prefix.dyn',\n  epsil = .false.,\n  ldisp = .true.,\n  recover = .true.,\n  nq1 = Nx,\n  nq2 = Ny,\n  nq3 = Nz\n/\n</code></pre>"},{"location":"running/#yambo-save-directory","title":"Yambo SAVE Directory","text":"<p>Run:</p> <pre><code>$ p2y\n$ yambo\n</code></pre> <p>Move the SAVE directory to a convenient location.</p>"},{"location":"running/#obtain-el-ph-databases","title":"Obtain El-ph Databases","text":"<pre><code>yambopy l2y\n</code></pre> <p>For serial run (bands <code>n_i</code> to <code>n_f</code>):</p> <pre><code>yambopy l2y -ph path/of/ph_input.in -b n_i n_f\n</code></pre> <p>For parallel calculation with 4 qpools and 2 kpools:</p> <pre><code>yambopy l2y -ph path/of/ph_input.in -b n_i n_f -par 4 2 -lelphc path/to/lelphc_exe -D\n</code></pre> <p>Check the <code>SAVE</code> folder:</p> <pre><code>ls SAVE/ndb.elph*\n</code></pre> <p>This contains the Yambo-compatible databases.</p>"}]}